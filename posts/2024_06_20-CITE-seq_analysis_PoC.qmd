---
title: "CITE-seq analysis proof-of-concept"
author: "Patrick Cherry"
date: "June 20, 2024"
categories:
  - multi-modal analysis
  - CITE-seq
  - scRNA-seq
  - code
  - data
image: "2024_06_20-CITE-seq/tsne_rna_adtClusters.png"
format:
  html:
    df-print: kable
execute:
  freeze: TRUE
  echo: TRUE
editor_options: 
  chunk_output_type: inline
---

## Intro
CITE-seq using data from Stoeckius, et al (Nat Methods 14, 865â€“868 (2017) 10.1038/nmeth.4380) in GSE100866

Seurat multi-modal clustering

<!-- https://cran.r-project.org/web/packages/dsb/vignettes/end_to_end_workflow.html -->
<!-- https://broadinstitute.github.io/2020_scWorkshop/cite-seq.html -->

### Methods Intro
From [Supplementary Figure 1 CITE-seq library preparation](https://www.nature.com/articles/nmeth.4380#Sec18):

 > Illustration of the DNA-barcoded antibodies used in CITE-seq. (b) Antibody-oligonucleotide complexes appear as a high-molecular-weight smear when run on an agarose gel (1). Cleavage of the oligo from the antibody by reduction of the disulfide bond collapses the smear to oligo length (2). (c) Drop-seq beads are microparticles with conjugated oligonucleotides comprising a common PCR handle, a cell barcode, followed by a unique molecular identifier (UMI) and a polyT tail. (d) Schematic illustration of CITE-seq library prep in Drop-seq (downstream of Fig. 1b). Reverse transcription and template switch is performed in bulk after emulsion breakage. After amplification, full length cDNA and antibody-oligo products can be separated by size and amplified independently (also shown in d) (e) Reverse transcription and amplification produces two product populations with distinct sizes (left panel). These can be size separated and amplified independently to obtain full length cDNAs (top panel, capillary electrophoresis trace) and ADTs (bottom panel, capillary electrophoresis trace).

```{r setup, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse, quietly = TRUE)
library(patchwork)
library(fs)
library(here)
library(Seurat)
library(Matrix)
library(testthat)
theme_set(theme_light())
out_path <- fs::path(here(), "posts", "2024_06_20-CITE-seq")
file_prefix <- "CITE-seq"
data_dir <- fs::path("~/", "pdcherry_github_data", "CITE-seq_data", "GSE100866")
```
```{r}
fs::dir_ls(data_dir) |> fs::path_file()
```

```{r}
path(out_path, file_prefix)
```

```{r eval = FALSE}
#| eval: FALSE
source("CITE-seq_data_fetch.R")
```
```{r}
cat(readLines(fs::path(out_path, "CITE-seq_data_fetch.R")), sep = "\n")
```

## Read in data
### count data
```{r}
cbmc_rna <-
  as.sparse(
    read.csv(
      path(data_dir, "GSE100866_CBMC_8K_13AB_10X-RNA_umi.csv.gz"),
      sep = ",", header = TRUE, row.names = 1))
```
```{r}
dim(cbmc_rna)
```

`dim()` outputs (columns, rows); the CBMC matrix (cord blood mononuclear cells) contains 36280 features and 8617 samples (single cell droplets).

```{r}
cbmc_rna <- CollapseSpeciesExpressionMatrix(cbmc_rna,
                                            prefix = "HUMAN_", controls = "MOUSE_",
                                            ncontrols = 100)
```
```{r}
dim(cbmc_rna)
```
 
`CollapseSpeciesExpressionMatrix()` is a convenience function for slimming down a multi-species expression matrix, when only one species is primarily of interest. Given the default parameter of `ncontrols = 100`, this command keeps only the top 100 features detected from each species in each sample. This matrix went from 36280 to 20501 features, which is a 43% reduction.

### ADT UMI matrix
```{r}
cbmc_adt <-
  as.sparse(
    read.csv(
      path(data_dir, "GSE100866_CBMC_8K_13AB_10X-ADT_umi.csv.gz"),
      sep = ",", header = TRUE, row.names = 1))
```
```{r}
dim(cbmc_adt)
```

#### Quick matrix QC
```{r test UMI counts of rna and adt matrices}
testthat::expect_equal(dim(cbmc_rna)[2] == dim(cbmc_adt)[2],
                       TRUE)
```

The number of rows (samples / UMIs) matches the RNA counts matrix; we have corresponding sample data.

```{r}
length(intersect(colnames(cbmc_rna), colnames(cbmc_adt))) /
  length(union(colnames(cbmc_rna), colnames(cbmc_adt)))
```

And the names of the samples all match.

## Seurat object & cluster
```{r}
cbmc <- CreateSeuratObject(counts = cbmc_rna)
```
```{r}
cbmc <- NormalizeData(cbmc)
```
```{r}
cbmc <- FindVariableFeatures(cbmc)
```
```{r}
cbmc <- ScaleData(cbmc)
```

```{r}
#| label: elbowplot
#| fig-cap: "Elbow plot of principle components computed from scRNA-seq counts"

cbmc <- RunPCA(cbmc, verbose = FALSE)
ElbowPlot(cbmc, ndims = 50)
```

The elbow plot above shows some interesting PC influence behavior. There are some clusters PCs (like 4-7, 8-10, and 11-13) that make it less clear where the "elbow" of influence trend is. To be very safe, we can keep up to PC 25, where the trend approaches a horizontal line.

```{r}
cbmc <- FindNeighbors(cbmc, dims = 1:25)
cbmc <- FindClusters(cbmc, resolution = 0.8)
```
```{r}
cbmc <- RunTSNE(cbmc, dims = 1:25, method = "FIt-SNE")
```
```{r}
#| message: FALSE
cbmc_rna_markers <-
  FindAllMarkers(cbmc,
                 max.cells.per.ident = 100, logfc.threshold = log(2),
                 only.pos = TRUE, min.diff.pct = 0.3, verbose = FALSE)
```

The following cluster identities are provided for us from the authors of the paper. A cell-type classifier would need to be run on the data to label the barcodes (droplets) with their identifiers.
```{r}
new.cluster.ids <- c("Memory CD4 T", "CD14+ Mono", "Naive CD4 T", "NK", "CD14+ Mono",
                    "Mouse", "B", "CD8 T", "CD16+ Mono", "T/Mono doublets", "NK", "CD34+",
                    "Multiplets", "Mouse", "Eryth", "Mk", "Mouse", "DC", "pDCs")
names(new.cluster.ids) <- levels(cbmc)
cbmc <- RenameIdents(cbmc, new.cluster.ids)
```


### Clustering t-SNE plot
```{r}
#| label: tsne-plot-rna
#| fig-height: 4
#| fig-width: 7
#| fig-cap: "t-SNE plot of scRNA-seq expression levels showing 18 clusters"

DimPlot(cbmc, label = TRUE, reduction = "tsne")# + NoLegend()
```

## Incorporate protein expression (antibody barcodes) to the Seurat object
```{r}
cbmc[["ADT"]] <- CreateAssayObject(counts = cbmc_adt)
```

The above code adds a new assay called "ADT" to the Seurat object `cmbc`. We can confirm it's added with the following `GetAssayData()` command.

```{r}
GetAssayData(cbmc, layer = "counts", assay = "ADT")[1:3,1:3]
```
```{r}
rownames(cbmc_adt)
```

Now we can repeat the pre-processing (normalization and scaling) steps that we typically run with RNA, but modifying the 'assay' argument.

(For CITE-seq data, the Broad does not recommend typical LogNormalization. Instead, they use a centered log-ratio (CLR) normalization, computed independently for each feature. This is a slightly improved procedure from the original publication.)

```{r}
cbmc <- NormalizeData(cbmc, assay = "ADT", normalization.method = "CLR")
```
```{r}
cbmc <- ScaleData(cbmc, assay = "ADT")
```

```{r}
DefaultAssay(cbmc) <- "RNA"
```

### Visualize protein levels on RNA clusters
```{r}
#| fig-height: 7
#| fig-width: 14
FeaturePlot(cbmc, features = c("adt_CD3", "adt_CD11c", "adt_CD8", "adt_CD16",
                               "CD3E", "ITGAX", "CD8A", "FCGR3A"),
            min.cutoff = "q05", max.cutoff = "q95", ncol = 4)
```

```{r}
#| fig-height: 7
#| fig-width: 18
# Compare gene and protein expression levels for the other 6 antibodies.
FeaturePlot(cbmc,
            features = c("adt_CD4", "adt_CD45RA", "adt_CD56",
                         "adt_CD14", "adt_CD19", "adt_CD34",
                         "CD4", "PTPRC", "NCAM1",
                         "CD14", "CD19", "CD34"),
            min.cutoff = "q05", max.cutoff = "q95", ncol = 6)
```

```{r}
#| fig-width: 7.5
#| fig-height: 9
#| message: FALSE
RidgePlot(cbmc, features = c("adt_CD3", "adt_CD11c", "adt_CD8", "adt_CD16"), ncol = 2)
```

```{r}
FeatureScatter(cbmc, feature1 = "adt_CD19", feature2 = "adt_CD3")
```

```{r}
FeatureScatter(cbmc, feature1 = "adt_CD3", feature2 = "CD3E")
```

```{r}
FeatureScatter(cbmc, feature1 = "adt_CD4", feature2 = "CD4")
```

### T-cell analysis
```{r}
tcells <- subset(cbmc, idents = c("Naive CD4 T", "Memory CD4 T", "CD8 T"))
FeatureScatter(tcells, feature1 = "adt_CD4", feature2 = "adt_CD8")
```

The pearson correlation of CD4 and CD8 antibody CITE-seq signal is -0.79, indicating these are signals are significantly anti-correlated, which is consistent with the immunology of T-cells.

```{r}
FeatureScatter(tcells, feature1 = "adt_CD4", feature2 = "adt_CD8", slot = "counts")
```

```{r}
FeatureScatter(tcells, feature1 = "CD4", feature2 = "CD8A");
```

```{r}
ncol(subset(tcells, subset = CD4 == 0 & CD8A == 0)) / ncol(tcells)
```

Wow, when measured by RNA expression, 83% of the T-cells are double-negative for CD4 and CD8.

```{r}
DefaultAssay(tcells) <- "ADT"  # work with ADT count matrix
FeatureScatter(tcells, feature1 = "adt_CD4", feature2 = "adt_CD8")
```
```{r}
ncol(subset(tcells, subset = adt_CD4 < 1 & adt_CD8 < 1)) / ncol(tcells)
```

However, for surface antigen detection in CITE-seq, only 0.997% are double negative for CD4 protein and CD8 protein.

## differential protein levels between clusters
Here, I sample 300 sells
```{r}
cbmc_subset <- subset(cbmc, downsample = 300)

# Find protein markers for all clusters, and draw a heatmap
adt_markers <- FindAllMarkers(cbmc_subset, assay = "ADT", only.pos = TRUE)
```

```{r}
#| fig-height: 8
#| fig-width: 7
DoHeatmap(cbmc_subset,
          features = unique(adt_markers$gene),
          assay = "ADT", angle = 90, size = 4) +
  #NoLegend() +
  guides(color = "none") +
  theme(axis.text.y = element_text(size = 14),
        strip.text = element_text(size = 2))
```

### Cluster directly on protein levels
Keeping human cells only:
```{r}
cbmc <- subset(cbmc, idents = c("Multiplets", "Mouse"), invert = TRUE)
```
```{r}
DefaultAssay(cbmc) <- "ADT"
cbmc <-
  RunPCA(cbmc,
         features = rownames(cbmc),
         reduction.name = "pca_adt", reduction.key = "pcaadt_",
         verbose = FALSE)
```

I'm using `reduction.name` and `reduction.key`, because this is the second PCA being run on this multi-modal Seurat object, and I don't want the names to collide with the scRNA-seq PCA.

```{r}
DimPlot(cbmc, reduction = "pca_adt")
```

```{r}
ElbowPlot(cbmc)
```

```{r}
adt_data <- GetAssayData(cbmc, slot = "data")
adt_dist <- dist(t(adt_data))

cbmc[["rnaClusterID"]] <- Idents(cbmc)
```

```{r}
cbmc[["tsne_adt"]] <- RunTSNE(adt_dist, assay = "ADT", reduction.key = "adtTSNE_")
cbmc[["adt_snn"]] <- FindNeighbors(adt_dist)$snn
```

```{r}
cbmc <- FindClusters(cbmc, resolution = 0.2, graph.name = "adt_snn")
```

```{r}
( clustering_table <- table(Idents(cbmc), cbmc$rnaClusterID) )
```

```{r}
# new_cluster_ids <- c("CD4 T", "CD14+ Mono", "NK", "B",
#                      "CD8 T", "NK", "CD34+", "T/Mono doublets",
#                      "CD16+ Mono", "pDCs", "B")

new_cluster_ids <- levels(unique(cbmc$rnaClusterID))

names(new_cluster_ids) <- levels(cbmc)
```

```{r}
levels(unique(cbmc$rnaClusterID))
```

```{r}
names(new_cluster_ids)
```

```{r}
levels(cbmc)
```

```{r}
cbmc <- RenameIdents(cbmc, new_cluster_ids)
```

```{r}
#| label: fig-pairedtSNE
#| fig-cap: Juxaposed tSNE plots of ADT (antibody) signal, colored and labeled by the data source indicated in the title (classification based on scRNA-seq in a; classification based on ADT signal in b).
#| fig-width: 8
#| fig-height: 5.5
# using {patchwork} `wrap_plots` & `plot_annotation` to label sub-figures.

tsne_rnaClusters <- DimPlot(cbmc, reduction = "tsne_adt", group.by = "rnaClusterID", pt.size = 0.5) +
  NoLegend() +
  ggtitle("Classification based on scRNA-seq") +
  theme(plot.title = element_text(size = 12, hjust = 0.5))

tsne_rnaClusters <- LabelClusters(plot = tsne_rnaClusters, id = "rnaClusterID", size = 4)

tsne_adtClusters <- DimPlot(cbmc, reduction = "tsne_adt", pt.size = 0.5) +
  NoLegend() +
  ggtitle("Classification based on ADT signal") +
  theme(plot.title = element_text(size = 12, hjust = 0.5))

tsne_adtClusters <- LabelClusters(plot = tsne_adtClusters, id = "ident", size = 4)

# Note: for this comparison, both the RNA and protein clustering are visualized on a tSNE
# generated using the ADT distance matrix.
( tsne_rna_adtClusters <- patchwork::wrap_plots(list(tsne_rnaClusters, tsne_adtClusters), ncol = 2) +
  plot_annotation(tag_levels = 'a') )
```
```{r eval = FALSE, include = FALSE}
ggsave(fs::path(out_path, "tsne_rna_adtClusters.png"), tsne_rna_adtClusters,
       dpi = 320, units = "in", width = 906/72/1.5, height = 603/72/1.5)
```

The tSNE clustering in @fig-pairedtSNE above is based on the distance matrix ADT (antibody) signal, whereas the coloring and cluster labels are, on the scRNA-seq data.

Overall, the ADT-driven clustering yields similar results. The compare / contrast are:

  - ADT clustering is improves CD4/CD8 T cell group distinction, based on the robust ADT data for CD4, CD8, CD14, and CD45RA
  - However, ADT-based clustering is worse for the Mk/Ery/DC cell-surface markers, and scRNA-seq distinguishes these populations better.
  - Some of the clusters are likely doublets, which have low confidence classifier calls in both the scRNA-seq and ADT methods. (However, scRNA-seq could have more features for more confident doublet identification and removal.)

